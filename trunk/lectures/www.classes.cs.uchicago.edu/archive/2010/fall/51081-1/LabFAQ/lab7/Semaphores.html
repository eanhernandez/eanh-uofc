<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Synchronization:  Semaphores</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><h1>Synchronization:  Semaphores</h1><h3>Goal</h3><p>    The goal of this tutorial is explain how semaphores can be used to solved synchronizationproblems, which arise through cooperation between processes.  The tutorial will start with thebasics on creating and setting-up semaphores, then tackle the most basic use of semaphores, to protect <em>critical sections</em> of code.  Finally, the <em>Bounded Buffer Problem</em>, described inthe tutorial on <strong>Cooperation</strong>, will be tackled.	</p><h3>The Critical Section  Problem</h3><p>     I assume you have read the tutorial on cooperating processes, and Interprocess Communication (IPC)facilities provided by the Operating System for process cooperation.  The most synchronization problem confronting cooperating processes, is controling access to shared resource.  Suppose two processes share access to a file, or shared memory segment (or when we discuss threads in a couple ofweeks, we'll see threads share the same memory, so they must synchronize their actions), and at leastone of these processes can modify the data in this shared area of memory.  That part of the code ofeach program, where one process is reading from or writing to a shared memory area, is a <em>critical section</em> of code, because we must ensure that only one process execute a critical sectionof code at a time.  The Critical Section Problem is to design a protocol that the processes can useto coordinate their activities when one wants to enter its critical section of code.	 </p><p>     Suppose we have two processes that share a memory segment of four bytes which storesan integer value.  Let this value be named by the variable <code>V</code>.  Process 1 (P1)and Process 2 (P2) have a section of code with the following lines:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if (0 &lt; V)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code> V--;</code><br><br> These lines of code will be part of a <em>critical section</em> of code, because it is importantthat each process be allowed to execute all of them without interference from the other process.  Here is anexample of how the processes can interfere with each other:<ol>	<li><code>V</code> has the value 1</li>	<li>P1 tests <code>0 &lt; V</code>, which is true</li>	<li>P1 is removed from the CPU and replaced by P2</li>	<li>P2 tests <code>0 &lt; V</code>, which is true</li>	<li>P2 executes <code> V--</code>, so <code>V</code> has the value 0</li>	<li>P1 given back the CPU and starts where it last left off:		 executing <code> V--</code>, so <code>V</code> has the value -1</li></ol>By interfering with each other during the execution of the lines of code, the two processes caused thevalue of the common variable <code>V</code> to drop below 0, which they were trying to prevent fromhappening.</p><p>     The protocol developed for solving the Critical Section Problem involved three steps:<ol>	<li><strong>Entry section</strong>:  Before entering the critical section, a process		must request permission to enter</li>	<li><strong>Critical section</strong>:  After permission is granted, a process may execute the code in		the critical section.  Other processes respect the request, and keep out of their		critical sections.</li>	<li><strong>Exit section</strong>:  The process acknowledges it has left its critical section.</li>		</ol>	 The problem that remains is how to effectively implement this protocol.  How can the processescommunicate their requests and grant their permissions so that only one process at a time is ina critical section. </p><h3>The Solution</h3><p>    The Dutch scientist E.W. Dijkstra showed how to solve the <em>Critical Section Problem</em> in themid-sixties, and introduced the concept of a semaphore to control synchronization.	A <em>semaphore</em>is an integer variable which is accessed through through two <em>special</em>operations, called <code>wait</code> and <code>signal</code>.  Why we need <em>special</em> operationswill be discussed shortly.  Originally, Dijkstra called the two special operations <code>P</code> (for <em>proberen</em>, thedutch word for test) and <code>V</code> (for <em>verhogen</em>, the dutch word to increment).   Let<code>S</code> be an integer variable, our semaphore, then the classical definition of <code>wait</code>is given by<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wait(S) {</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>while(S &le; 0);</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>S--;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>}</code><br><br> and <code>signal</code> is given by<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>signal(S) {</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>S++;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>}</code><br><br>We can use the semaphore to synchronize our processes:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Entry Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wait(S);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Critical Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if (0 &lt; V)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code> V--;</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Exit Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>signal(S);</code><br><br><ol>	<li>Process P calls <code>wait(S)</code></li>	<li>While <code>S</code> is 0, P waits.</li>	<li>When <code>S</code> is 1, P is allowed to enter its critical section</li>	<li>While P is in its critical section, the value of <code>S</code> is zero,		blocking other processes from entering their critical section.</li>	<li>When P is finished and ready to leave its critical section, it executes		<code>signal</code> resetting <code>S</code> to 1 and allowing another		process to enter.</li>	</ol>A semaphore which can take the value zero or one is called a <em>binary</em> semaphore, or<em>mutex</em>, for <em>mut</em>ually <em>ex</em>clusive.</p> <p>There is a glaring weakness with this implementation:  the code for <code>wait</code> is no betterthan the code we were trying to protect:  For the semaphore to work, <code>S</code> must be shared,so it is tested and changed in <code>wait</code>, and this requires synchronization betweenthe processes; so how does this resolve the original problem?</p><h3>Atomic Operations</h3><p>     The problem we have is that we have some lines of code which need to be executed withoutinterference from other processes; this is no problem as long as a process has control of the CPU,but if it is taken-off the CPU by the Operating System before it can finish executing its section ofcode, another process may have an opportunity to trash its work.  The code must be run<em>atomically</em>:  in one uninterruptible unit.  So, for semaphores to solve the problem, theimplementation of the two functions <code>wait</code> and <code>signal</code> must be atomic:  therecan be no interruptions while these operations are being implemented.	 </p><p>     Operating systems, like Unix, which have semaphores, guarantee that the operations <code>wait</code> and <code>signal</code> are run atomically.  How can they do this?  It is the Operating System that determines when to switch a process off the CPU; while the Operating Systemcannot decide when it must leave a process on the CPU, it can govern its own CPU use.  So, the OperatingSystem keeps track of the semaphore and its value:  when processes call operations on the semaphoresuch as <code>wait</code> and <code>signal</code> they are actually making system calls which requestthe Operating System to check the semaphore and change its value.  The Operating System	then stepsin and performs the operation, without interruption. </p>	 <h3>System V Semaphores</h3><p>    Unix System V introduced semaphores to Unix in the mid-eighties.  Since the Operating Systemmaintains semaphores and operates on them, the actual code required is rather complicated.  To addto this confusion, a Unix semaphore is not really a single integer value, but an array of integer values.We'll see later why we may want to use more than one semaphore.  I will refer to Unix semaphores assemaphore structures, since they include (possibly) multiple semaphores.</p><p>     Semaphores are to be shared by processes which are unrelated to each other. This means that theyneed to have some means of coordinating their access to the <em>same</em> semaphore.  The way this isdone is for all processes which will use the semaphore to exchange a shared <em>key</em> value.This <em>key</em> value is defined the same way in each process.  The value of the <em>key</em> canbe any integer, although if there already exists a semaphore structure with that <em>key</em>, thatsemaphore will be used.   One way to be sure that your <em>key</em> is unique is to see what semaphore structures the system already has set-up.  Typing <code>ipcs -sem</code> on the command linewill list all semaphore structures.  Unix only allows a few semaphore structures at a time (a maximumof 10 in the whole system), so most any <em>key</em> you choose is likely to be unique.</p><p>    There are five basic steps in allocating a semaphore structure:<ol>		<li> Request a semaphore structure, using the common <em>key</em></li>		<li> Initialize the semaphore structure by setting the values of each semaphore</li>		<li> Define the basic operations we want to perform on the semaphore structure</li>		<li> Use the basic operations in our program </li>		<li> Remove the semaphore structure when we are done with it.</li></ol>The first step is a request of a semaphore structure.  <table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">semget</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td valign="top">Purpose</td>    <td>Request a semaphore structure</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;sys/types.h&gt;</font><br>	    <font face="Courier New, Courier, mono">#include&lt;sys/ipc.h&gt;</font><br>		<font face="Courier New, Courier, mono">#include&lt;sys/sem.h&gt;</font>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">		int &nbsp;semget(key_t <em>key</em>, int <em>numsems</em>, int <em>flag</em>)</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">key</font>:  &nbsp;&nbsp; key value<br>		<font face="Courier New, Courier, mono">numsems</font>:  &nbsp;&nbsp; number of semaphores<br>		<font face="Courier New, Courier, mono">flag</font>:  &nbsp;&nbsp; IPC_CREAT or IPC_EXCL	</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		semaphore ID if successful	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td><font face="Courier New, Courier, mono">ENOMEM</font>:&nbsp;&nbsp;No memory available<br>		<font face="Courier New, Courier, mono">EEXIST</font>:&nbsp;&nbsp;structure exists and IPC_EXCL set	</td>  </tr></table><br>There are three ways you may want to call <code>semget</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//Create the structure if it doesn't exist</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//or use an existing structure with the same key</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semaid = semget(<em>key</em>, <em>numsems</em>, IPC_CREAT);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//Require a new structure is created:</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//Throws an error if a structure exists with the key</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semaid = semget(<em>key</em>, <em>numsems</em>, IPC_CREAT | IPC_EXCL);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//Create the structure if it doesn't exist using a private key</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//The return value semaid can only be shared with related processes </code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semaid = semget(IPC_PRIVATE, <em>numsems</em>, IPC_CREAT);</code><br><br>The return value <code>semaid</code> will be used to refer to the semaphore structure in all furtherfunctions.	</p><p>     Once you have the <code>semaid</code>, you initialize the structure, by setting the value of everysemaphore in the set.  The function for doing this is <code>semctl</code> which is a catch-all for alotof different functions.  You will want to see the manpages:  <code>man 2 semctl</code> for all the details.	 <table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">semctl</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td valign="top">Purpose</td>    <td>Mainly to remove a semaphore structure from the system, and to set the values of each		semaphore in the structure.</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;sys/types.h&gt;</font><br>	    <font face="Courier New, Courier, mono">#include&lt;sys/ipc.h&gt;</font><br>		<font face="Courier New, Courier, mono">#include&lt;sys/sem.h&gt;</font>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">		int semctl(int <em>semaid</em>, int <em>semnum</em>, int <em>cmd</em>, union semun <em>arg</em>);</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">semaid</font>:  &nbsp;&nbsp; semaphore ID<br>		<font face="Courier New, Courier, mono">semnum</font>:  &nbsp;&nbsp; between 0 and numsems-1<br>		<font face="Courier New, Courier, mono">cmd</font>:  &nbsp;&nbsp; <font face="Courier New, Courier, mono">SETVAL</font> or <font face="Courier New, Courier, mono">SETALL</font><br>		<font face="Courier New, Courier, mono">arg</font>:  &nbsp;&nbsp; see below<br>	</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>0, for the two commands above<br>	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td>NONE</td>  </tr></table>Using this structure is a little complicated, so lets start with the definition of <code>union semun</code>.This union structure is not actually defined in any of the header files, so you will have to definethe structure in your program before you call <code>main</code>:<br><br><code>        union semun { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    int val; /* used for SETVAL only */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        struct semid_ds *buf; /* for IPC_STAT and IPC_SET, not discussed here */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        ushort *array;  /* used for GETALL and SETALL */ <BR>       };  <BR><BR></code> To make the discussion concrete, I will consider how to set the value of the semaphore structure in  two cases:  where we want to set one particular semaphore, and when we want to set the value for  all semaphores at once (the case of two semaphores in the structure).  Here is the code to set one semaphore in a set<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>union semun &nbsp;&nbsp;&nbsp;arg;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>arg.val = 1; </code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>//This sets the first semaphore to the value 1</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   <code>//(numbering starts at 0)</code><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semctl(semaid, 0, SETVAL, arg); </code><br><br>If we want to set all the values of the semaphore structure, we need an array of integers, and to seteach value in the array:<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>union semun &nbsp;&nbsp;&nbsp;arg;</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>int &nbsp;&nbsp;&nbsp;arr[2];</code><br></code>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>arr[0] = 1; </code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>arr[1] = 5; </code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>arg.array = arr; </code><br><br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <code>//Second argument is not used</code><br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semctl(semaid, 0, SETALL, arg); </code><br><br> </p>  <p>      We use a special structure type, <code>struct sembuf</code>, to define the basic operations we want to define on the semaphore set. Here is the structure:<br><br><code>        struct sembuf { <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    int sem_num; /* member # in {0, . . . , numsems - 1} */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        short sem_op; /* operation:  negative, zero, positive */ <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                        short sem_flag;  /* IPC_NOWAIT or SEM_UNDO */ <BR>       };  <BR><BR></code>Each argument is important:<br><br><ul>	<li><code>sem_num</code>: &nbsp;&nbsp;This refers to the particular semaphore we		are going to adjust in the semaphore structure.  The number of semaphores,		<code>numsems</code> was determined when the semaphores structure was created,		using <code>semget</code>.  Counting starts at 0.</li>	<li> <code>sem_op</code>: &nbsp;&nbsp;The operation we will perform on the semaphore.	  <ul>	  	<li><em>positive</em>:  the value is added to the semaphore's current value</li>		<li><em>negative</em>:  the value is added to the semaphore's current value, provided the			current value is at least zero.  If the value would be less than zero, the			process will wait for the value to become large enough so that the sum is at			least zero.  If the flag <code>IPC_NOWAIT</code> is set, process does not wait.</li>		<li><em>zero</em>:  the process waits for the value of the semaphore to reach zero, unless		 	<code>IPC_NOWAIT</code> is specified.</li>		  </ul>	</li>	<li><code>sem_flag</code> One of two possible flags:	  <ul>	  	<li><code>IPC_NOWAIT</code>:  do not wait on the semaphore, return immediately if the			operation cannot be carried-out.  In this case, the error <code>EAGAIN</code>			is returned.</li>		<li><code>SEM_UNDO</code>:  if the process should terminate before it can restore the			count on the semaphore, then the count is restored by the Operating System.  Suppose			your process decrements a semaphore, taking its value to zero, but terminates before it			can reset the semaphore back to one.  Any process waiting for the semaphore to be one			again would be stuck.  The Operating System takes care of this if this flag is set.</li>		  </ul>	</li></ul><br><br>Lets look at how we would set-up the semaphore operations <code>wait</code> and <code>signal</code>.  Suppose we have created a semaphore structure having one semaphore, with semaphore ID <code>semaid</code>, and this semaphore has been set to an initial value one.  The two operationswhich I will label <code>WAIT</code> and <code>SIGNAL</code> are defined as follows:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>struct sembuf &nbsp;&nbsp;&nbsp;WAIT[1], SIGNAL[1];</code><br><br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Defining WAIT</code><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WAIT[0].sem_num = 0;</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WAIT[0].sem_op = -1;</code><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>WAIT[0].sem_flag = SEM_UNDO;</code><br><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Defining SIGNAL</code><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SIGNAL[0].sem_num = 0;</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SIGNAL[0].sem_op = 1;</code><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>SIGNAL[0].sem_flag = SEM_UNDO;</code><br><br> </p> <p>    Using our semaphore actions is actually easy, we call the operation <code>semop</code><br><br><table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">semop</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td valign="top">Purpose</td>    <td>Implement a predefined action on a semaphore set</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;sys/types.h&gt;</font><br>	    <font face="Courier New, Courier, mono">#include&lt;sys/ipc.h&gt;</font><br>		<font face="Courier New, Courier, mono">#include&lt;sys/sem.h&gt;</font>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">	int semop(int <em>semaid</em>, struct sembuf <em>semoparray</em>[], size_t <em>nops</em>);</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">semaid</font>:  &nbsp;&nbsp; semaphore ID<br>		<font face="Courier New, Courier, mono">semopsarray</font>:  &nbsp;&nbsp; operations to be performed on the semaphores<br>		<font face="Courier New, Courier, mono">nops</font>:  &nbsp;&nbsp; length of semopsarray<br>	</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		SUCCESS	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td><p><font face="Courier New, Courier, mono">EAGAIN</font>:&nbsp;&nbsp;Process    would wait and <code>IPC_NOWAIT</code> set</p>    <p>&nbsp;</p></td>  </tr></table>Here is how our code protecting the critical section now looks<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Entry Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, WAIT, 1);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Critical Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if (0 &lt; V)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code> V--;</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Exit Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, SIGNAL, 1);</code><br><br> </p> <p> Removing a semaphore structure can only be done by the user ID of the creator of the semaphore structure. This can be done on the command line using <code>ipcrm semaid</code>, or you can explicitly remove the semaphore structure within the program using <code>semctl</code><br><br>  <code> int  semctl (semid, 0, IPC_RMID, 0) </code><BR><BR>  You will find more details at <a href="LabFAQ4.html">FAQ</a>. </p>  <h3>The Bounded Buffer Problem</h3> <p>      You will want to refresh your memory <a href="IPC.html#BBP">Bounded Buffer Problem</a>.  We nowadd an additional feature to our <em>Critical Section Problem</em>:  the shared resource is stored ina buffer, <code>BUFFER</code> (a storage facility for data) of limited size.We have two types of processes, Producers who try to add to <code>BUFFER</code> and Consumers whotry to remove from <code>BUFFER</code>.  One possible solution to this problem is to treat use a singlebinary semaphore just as in the <em>Critical Section Problem</em> together with a variable<code>COUNTER</code>, which is shared in common (say as a shared memory segment.)Here is code for the Consumer:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Entry Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, WAIT, 1);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Critical Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if (0 &lt; COUNT)</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code> COUNT--;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//OK to take from BUFFER</code><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>. . . BUFFER . . .</code><br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Exit Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, SIGNAL, 1);</code><br><br>  and for the producer<br><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Entry Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, WAIT, 1);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Critical Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if (COUNT &lt; BUFFER_MAX )</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code> COUNT++;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//OK to add to BUFFER</code> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>. . . BUFFER . . .</code><br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Exit Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, SIGNAL, 1);</code><br><br>	   </p>  <p>      This presents one solution to the <em>Bounded Buffer Problem</em>, and in many circumstancesit may be perfectly fine.  But there is a problem which you should be aware of, that may makeits performance unsuitable<br><br><ul>	   <li>A Consumer must constantly poll <code>COUNTER</code> to test if it is positive.  Similarly,	   		a Producer must constantly poll <code>COUNTER</code> to test if it is below			<code>BUFFER_MAX</code>.</li></ul> Suppose a Consumer must have the data in the <code>BUFFER</code>, but <code>BUFFER</code> is empty. The only way to determine whether data has been added to the buffer is to continually enter the Critical Section and check <code>COUNTER</code>.  This creates what is called a <em>spinlock</em>,  where the process enters a useless cycle waiting for a resource.  If the resource will be  available quickly, this is not a problem; but if the resource may take some time, this spinlock  position wastes CPU time that could be more productively spent.  A solution to this problem is to use a semaphore to count as well.  A semaphore which is used as a counter is called a <em>counting</em> semaphore.   </p> <p>     It is pretty clear how we can use a counting semaphore to restrict the Consumer's behavior:set a semaphore to the value of <code>BUFFER_MAX</code>, and have each Consumer decrement its value,each Producer increment its value.  If the count goes to zero, Consumers are forced to wait.  Unfortunately, 	Unix System V semaphores effectively have no upper limit, so we cannot use just onecounter to control both Consumers and Producers.  Here is how we can implement a counter using semaphores.A Producer creates data and <em>fills</em> <code>BUFFER</code>, a Consumer takes data and <em>empties</em> <code>BUFFER</code>.  We use two semaphores to implement our counter:  <code>EMPTY</code> and <code>FULL</code>.  We need two actions on the counter <code>INCREMENT</code>and <code>DECREMENT</code>:  <br><br><ul>	<li><code>INCREMENT</code>:  Increment <code>FULL</code> and Decrement <code>EMPTY</code><br>		The idea is that a Producer fills one more spot in <code>BUFFER</code> and removes		one more empty spot</li>	<li><code>DECREMENT</code>:  Decrement <code>FULL</code> and Increment <code>EMPTY</code><br>		The idea is that a Consumer empties one more spot in <code>BUFFER</code> and removes		one more full spot</li>	</ul><p>By combining these two additional semaphores to keep count, with our binary semaphore we can solve the  <em>Bounded Buffer Problem</em>.  I'll show you how to define the action of <code>INCREMENT</code>for the Producer process (the action <code>SIGNAL</code> is the same as we saw before--resetingthe binary semaphore):<br>  <br>  <code>struct sembuf &nbsp;&nbsp;&nbsp;CONSUMER[3},PRODUCER[3], SIGNAL[1];</code><br>  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Defining PRODUCER</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Code for the binary semaphore</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[0].sem_num = 0;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[0].sem_op = -1;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODuCER[0].sem_flag = SEM_UNDO;</code><br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Defining INCREMENT</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Our FULL semaphore</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[1].sem_num = 0;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[1].sem_op = 1;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[1].sem_flag = SEM_UNDO;</code><br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Defining INCREMENT</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//Our EMPTY semaphore</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[2].sem_num = 0;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[2].sem_op = -1;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>PRODUCER[2].sem_flag = SEM_UNDO;</code><br> <br> I'll leave the defining of the action <code>CONSUMER</code> to you.  Here is the new implementationfor the <em>Bounded Buffer Problem</em> for the Consumer and Producer:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Entry Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, CONSUMER, 3);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Critical Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>//OK to take from BUFFER</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>. . . BUFFER . . .</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>// Exit Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>semop(semaid, SIGNAL, 1);</code><br><br>and code for the Producer <br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>// Entry Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>semop(semaid, PRODUCER, 3);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>// Critical Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>//OK to add to BUFFER</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>. . . BUFFER . . .</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>// Exit Section</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>semop(semaid, SIGNAL, 1);</code> </p></p></body></html>
