<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Deconstructing Make</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><h1>Deconstructing Make</h1><p> <em>Make</em> is a command generator:  using a description file it generates a sequence of commandsto be executed by the Unix shell.  Make is most naturally used to sort out the dependency relationsamong files, so that it executes only the commands that need to be executed, in the order they must beexecuted.  You record once and for all the relationships between files, and from then on merelytype<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">make</font>  <em>myprogram</em><br>and let <em>make</em> build your project.  <em>Make</em> saved my life, and it started with my tryingto understand the Makefiles I needed to do this project.  Perhaps, I can pass some of this on to you.</p><p><em>Make</em> builds a target and anything that is required to build that target, by following asequence of dependency relations which layout the commands that must be executed and the orderthose commands are to be executed. <em>Make</em> assumes<ul>	<li>The files you are going to build and the description file that determines how to build these		files, reside in the same directory.</li>	<li>The desciption file is named <em>makefile</em> or <em>Makefile</em>.</li>	<li>The directory containing these files is the current directory where you enter the command		make.</li>	</ul>There is one simple rule you must know and never forget<br><blockquote><h3>Tab Rule</h3>If the first character on a line is a &lt;<strong>TAB</strong>&gt;then what follows the &lt;<strong>TAB</strong>&gt; is a command to be executed by the UnixShell. </blockquote><br>If the first character on a line is a &lt;<strong>TAB</strong>&gt; and your line contains<em>anything else</em> you will get an error message.  If you feel especially cautious, you may execute <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">cat -v -t -e makefile</font><br>which will display every &lt;<strong>TAB</strong>&gt; as <font face="Courier New, Courier, mono">^I</font>and place <font face="Courier New, Courier, mono">$</font> at the end of every newline.  Shall we begin?</p><p>You will want the <font face="Courier New, Courier, mono">Makefile</font> for the static library in front of you.  The first line is<br><font face="Courier New, Courier, mono">all:  myapp</font><br>A <em>makefile</em> consists of lines which display dependencies needed to build a target and lines which display the commands to be executed.  This first line is a <em>dependency line</em> and consists of<br><ul> 	<li>A <em>target</em> to be build:  <em>all</em>.</li>	<li>The files this target depends upon to build it:  <em>myapp</em>.</li></ul> There are no commands following this line, there are no instructions given to make, immediately, to  build this target <em>all</em>.  You run <em>make</em> from the command line by executing the  command make and specifying the target make is to build:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono"> make all</font><br>If you do not specify a target<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono"> make</font><br><em> make</em> will build the first target on the list.  This brings us to our second rule of <em>make</em>:<br> <blockquote><h3>Order of Construction</h3> <em>Make</em> starts with the target it is to build and works downward in the file in determining all prerequisites which must be built, to build the target.  Once <em>make</em> reaches the bottom of the file, it proceeds to build the target by executing all commands required. </blockquote><br>In order to build <em>all</em> make starts with <em>myapp</em> and tries to figure-out how to build it.</p><p>The next pair of lines in <font face="Courier New, Courier, mono">Makefile</font> are <br><br><font face="Courier New, Courier, mono">#Which compiler<br>CC = gcc</font><br><br>The first line is a comment.  All comments begin with <font face="Courier New, Courier, mono">#</font> and extend to the end of the line.  The second line is a <em>macro definition</em>.  A macro definition consists of :  <em>name</em> <font face="Courier New, Courier, mono">=</font> <em>string</em>.  The <em>name</em> is then used by typing either ${<em>name</em>} or $(<em>name</em>);  every occurrence of $(<em>name</em>) in the file is then replaced with <em>string</em>.  So, everywhere in the file you now see $(CC), <em>make</em> will replace with <font face="Courier New, Courier, mono">gcc</font>.  <em>Make</em> follows simple rules with the string on the right-hand side:  <em>what-you-see-is-what-you-get</em>.   <em>Make</em> treats all space immmediately preceeding the   <font face="Courier New, Courier, mono">=</font> as a single space, everything else is exactly as it   appears.</p><p>I'll skip past several more macro definitions, and arrive at our first interesting line<br><br><font face="Courier New, Courier, mono">myapp: main.o $(MYLIB)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC) -o myapp main.o $(MYLIB)</font><br><br>The first line is a dependency line:  it says <font face="Courier New, Courier, mono">myapp</font>depends on the following files.	The second line begins with a &lt;<strong>TAB</strong>&gt;, and sois a command line.  This brings us to another fundamental rule of <em>make</em><br><blockquote><h3>Building Targets</h3><em>Make</em> assumes all targets are files to be built.  If the file does not exist, <em>make</em>builds it.  If the file does exist <em>make</em> checks all dependencies:  if any dependency has beenchanged since the target was built, <em>make</em> rebuilds the target.  If there have been no changesin the dependencies since the target was last built, <em>make</em> skips the target. </blockquote>How does make know when a dependency has changed?Hint:  <font face="Courier New, Courier, mono">stat</font>.  <em>Make</em> will build<font face="Courier New, Courier, mono">myapp</font> after checking<ul>	<li>Is there a file in the current directory called <font face="Courier New, Courier, mono">myapp</font>?</li>	<li>Has the file <font face="Courier New, Courier, mono">main.o</font> <em>or any file that it	     depends</em> upon been changed since <font face="Courier New, Courier, mono">myapp</font> was last built.</li>	<li>Has the library <font face="Courier New, Courier, mono">mylib.a</font><em>or any file that it	     depends</em> upon been changed since <font face="Courier New, Courier, mono">myapp</font> was last built.		 (remember:  the name $(MYLIB) is replaced by the string <em>mylib.a</em>.) </li></ul>If <em>make</em> determines that <font face="Courier New, Courier, mono">myapp</font> needs to be built,it <em>does not</em> execute the next line.  Make proceeds to work its way to the end of the file todetermine all dependencies, and only then will it start building files.  It is important to realize, that <em>make</em> does not stop if<font face="Courier New, Courier, mono"> main.o</font> and <font face="Courier New, Courier, mono">mylib.a</font> are older than  <font face="Courier New, Courier, mono">myapp</font>; make will proceed to check if any file these  depend has been more recently changed as well.  <em>Make</em> will not stop until it has checked every dependency  on the file.</p><p>The next four lines go together, and are quite cryptic.  It is time to stop with <em>make</em>, and take a shortdiscursion into static libraries.</p><h2>Static Libraries</h2><p>Libraries are files created with an archive, <font face="Courier New, Courier, mono">ar</font>, utility.Libraries are really large collections of files which have been organized into a single file.  They areused by a <em>linker</em>, which extracts <em>modules</em> that are used by <em>executable</em> files.Libraries are typically found in a common directory such as <font face="Courier New, Courier, mono">/user/lib/</font>.  Libraries typically have a suffix <font face="Courier New, Courier, mono">.a</font> (for archive) to identify them, and often go by a name like <font face="Courier New, Courier, mono">libc.a</font> or <font face="Courier New, Courier, mono">libmath.a</font>.</p><p>A library is a single file, but it is made-up of other files with contain binary code.  These other files are called <em>object files</em>, and usually have the suffix <font face="Courier New, Courier, mono">.o</font>.  They are generated by the compiler using the <font face="Courier New, Courier, mono">-c</font> option.  Object files define functions, which may then be used by other programs. These functions are called <em>modules</em>, and a <em>linker</em> is  a special program which searches for the proper module in a library specified by a program, and links the module into the program.  This is precisely what happens when you call a function like <font face="Courier New, Courier, mono">printf</font> in C: the linker searches the known libraries  for a module which is probably called <font face="Courier New, Courier, mono">__printf</font>.  </p><p>     Libraries may be composed of many dozens of object files.  When one file is changed, the library doesnot need to be recreated, it only needs to be updated to include the new file.  This is where <em>make</em>comes in:  <em>make</em> can be told what files the library depends upon, and then <em>make</em> will maintain the libraryby only updating those files which have changed since the library was last built.</p><h3>Using Make to Maintain a Library:  Make isn't Stupid</h3><p>Now we come to the power of <em>make</em>:<blockquote><h3>Make can Build</h3>  <em>Make</em> knows alot about building things.</blockquote> <em>Make</em> knows how to build object files. When <em>make</em> sees a dependency line like<br><br> <font face="Courier New, Courier, mono">2.o:  2.c a.h b.h</font><br><br> without a command, <em>make</em> recognizes that it must build the object file <font face="Courier New, Courier, mono">2.o</font> by executing the command<br> <br> <font face="Courier New, Courier, mono">gcc -c 2.o 2.c</font><br><br> So, <em>make</em> knows how to build all three targets<br> <br><font face="Courier New, Courier, mono">main.o:  main.c a.h</font><br><font face="Courier New, Courier, mono">2.o:  2.c a.h b.h</font><br><font face="Courier New, Courier, mono">3.o:  3.c b.h c.h</font><br><br>The first line is really where the action takes place<br><br><font face="Courier New, Courier, mono">$(MYLIB):  $(MYLIB)(2.0) $(MYLIB)(3.o)</font><br><br>and the key to understanding it is the special way <em>make</em> treats the dependencies<font face="Courier New, Courier, mono">$(MYLIB)(2.0)</font> and <font face="Courier New, Courier, mono">$(MYLIB)(3.o)</font>.  <em>Make</em> expands the variable andknows <font face="Courier New, Courier, mono">$(MYLIB)(2.0)</font> is really<font face="Courier New, Courier, mono">mylib.a(2.0)</font>; the use of <font face="Courier New, Courier, mono">(2.o)</font> is a special signal to make that <font face="Courier New, Courier, mono"> mylib.a</font> is really a library and <font face="Courier New, Courier, mono">2.o</font> is an object file in that library.  This triggers make to treat<font face="Courier New, Courier, mono"> mylib.a</font> specially.</p><p><em>Make</em> knows how to build libraries.  It has a built in <em>rule</em> for constructing them<br><br><font face="Courier New, Courier, mono">.c.a:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC) -c $(CFLAGS) $&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar rv $@ $*.o<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rm -f $*.o</font><br><br>The first line is a <em>suffixing</em> rule:  it tells <em>make</em> how to builda target file whichends in <font face="Courier New, Courier, mono">.a</font> from a dependent filethat ends with <font face="Courier New, Courier, mono">.c</font>.   <em>Make</em> also used an implicitsuffixing rule whenit constructs a <font face="Courier New, Courier, mono">.o</font> file from a<font face="Courier New, Courier, mono">.c</font> file:<br><br><font face="Courier New, Courier, mono">.c.o:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC) -c $(CFLAGS) $&lt;</font><br><br>The second line in both rules is the same.  <em>Make</em> has several built in macro definitions whichit uses by default, unless you specifically overide the default definition (which has been done inthis file.)  The default definitions are<br><br><font face="Courier New, Courier, mono">CC = cc<br>CFLAGS = -O</font><br><br>Check yourself:  what are the values for these macros in the current file?  The other odd feature inthe command line following the suffix rule is <font face="Courier New, Courier, mono">$&lt;</font>, which is another specially defined macro definition.  There are several special macro definitions, soit is worth adding a new rule to cover them<h3>Internal Make Macros</h3><table width="75%" border="1" cellpadding="3">  <tr>    <td><font face="Courier New, Courier, mono">$@</font>, <font face="Courier New, Courier, mono">$@</font>  </td>    <td>The name of the current target.  <font face="Courier New, Courier, mono">$@</font> is used		in the command line, <font face="Courier New, Courier, mono">$@</font> is used on the		description line (to the right of the colon.) </td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">$?</font></td>    <td>The list of prerequisites which have been changed more recently than the current target.		Cannot be used in suffixing rule, but only in command line to a normal description line.</td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">$&nbsp;</font></td>    <td>The current prerequisite which has been changed more recently than the current target.	  	This may only be used in suffixing rules where the suffix of the prerequisite is given.</td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">$*</font></td>    <td>The name--without the suffix--of the current prerequisite that has been modified more recently		than the current target.  This may only be used in suffixing rules.</td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">%</font></td>    <td>Wildcard which will match any string.  But multiple occurrences on the same line refer to the		same string.</td>  </tr></table><br>So, for us, <font face="Courier New, Courier, mono">$&lt;</font> in the suffixing rule refers to a<font face="Courier New, Courier, mono">.c </font>file which will be used in building our <font face="Courier New, Courier, mono">.o</font>  (or <font face="Courier New, Courier, mono">.a</font>) file.  In fact, the suffixing rule is really  shorthand in <em>make</em>:<br>  <br>  <font face="Courier New, Courier, mono">.c.o:</font><br>  really means<br>  <font face="Courier New, Courier, mono">%.o: %.c</font><br><br>Let's go back to the construction of our library: <font face="Courier New, Courier, mono">mylib.a </font>using <em>make</em>'s internal suffixing rule<br><br><font face="Courier New, Courier, mono">.c.a:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(CC) -c $(CFLAGS) $&lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ar rv $@ $*.o<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rm -f $*.o</font><br><br>We now know what the first two lines mean.  The first line tells <em>make</em> how to build an archive fromits object files.  The second line says to compile each <font face="Courier New, Courier, mono">.c</font> file which have been modified more recently than our library.  This produces a <font face="Courier New, Courier, mono">.o</font> file by default from the compiler (this is because of the <font face="Courier New, Courier, mono">-c</font> option to <font face="Courier New, Courier, mono">gcc</font>.)The third and fourth lines are simple Unix commands.  The third line says to update the archive byplacing the <font face="Courier New, Courier, mono">.o</font> file just created (<font face="Courier New, Courier, mono">$*.o</font>) into <font face="Courier New, Courier, mono">mylib.a</font>  (<font face="Courier New, Courier, mono">$@</font>), while the fourth line removes the <font face="Courier New, Courier, mono">.o</font> file (which is now a member of the library.) <em> Make</em> performs this task separately for each file that requires updating into the library. This means that if your library has a hundred object files, but only one source code file has been updated since the library was last built, only that file will be used to update the library.   </p><p>There last two description lines should be simple now that we know <em>make</em>, but there are acouple new features that you need to know.  In the lines<br><br>clean:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-rm main.o 2.o 3.o $(MYLIB)<br><br>The first line contains a single target without a dependency.  This will only get executed if you specify<em>make</em> to build this target:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">make clean</font><br><br>In this case <em>make</em> will <em>always</em> build this target--i.e execute the command to remove the files.This is because <em>make</em> thinks all targets are files, and will build the target (if it determinesthe target must be built) if the target file does not exist.  In the case of <font face="Courier New, Courier, mono">clean</font>, as long as you have not created a file in your directory by this name,<em> make</em> will build the target (execute the command) every time it is requested to do so.</p><p>By default <em>make</em> prints the output of every command it executes, andstops whenever an error is  encountered. A leading hyphen before a command tells<em>make</em> to continue building, even when there areerrors (such as the file to be removed does not exist.)  Another useful prefixis the<font face="Courier New, Courier, mono">@</font> sign prefixed before a command,which tells <em>make</em> to suppress the normal output when executing the command. <em>Make</em>also recognizes an continuation of the current line onto the next line by usingabackslash, <em>as the last character</em> on a line before the newline.  Youmust not have anyspaces between the backslash and the newline (hence, the option <font face="Courier New, Courier, mono">-e </font>to <font face="Courier New, Courier, mono">cat</font> to help you debug your description file--remember.) You can apply your understanding of these features of <em>make</em>to the last dependency line in the file<br><br><font face="Courier New, Courier, mono">install: myapp</font><br><br>This line is used for installing the executable <font face="Courier New, Courier, mono">myapp</font> into the directory <font face="Courier New, Courier, mono">/usr/local/bin</font>when it has been completely debugged and is ready to be used.What follows is a Bash shell script which checks to see if the directory<font face="Courier New, Courier, mono">/usr/local/bin</font> really exists, then proceeds to installthe executable myapp into <font face="Courier New, Courier, mono">/usr/local/bin</font>, changing itsprivileges to allow anyone to execute it.</p><p><em>finis</em></p></body></html>