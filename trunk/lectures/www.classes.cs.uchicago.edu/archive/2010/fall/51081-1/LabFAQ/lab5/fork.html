<H2> Creating new processes: fork()</H2><PRE>#include &#60;sys/types.h&#62;#include &#60;unistd.h&#62;pid_t fork(void);</PRE><P>The <CODE>fork()</CODE> function is used to create a new process from anexisting process.  The new process is called the child process, and theexisting process is called the parent.  You can tell which is which bychecking the return value from <CODE>fork()</CODE>.  The parent gets thechild's pid returned to him, but the child gets 0 returned to him.  Thusthis simple code illustrate's the basics of it.</P><PRE>pid_t pid;switch (pid = fork()){case -1:    /* Here pid is -1, the fork failed */    /* Some possible reasons are that you're */    /* out of process slots or virtual memory */    perror("The fork failed!");    break;case 0:    /* pid of zero is the child */    /* Child can call getpid() to obtain its pid */default:    /* pid greater than zero is parent getting the child's pid */    printf("Child's pid is %d\n",pid);}</PRE><P>Of help when doing this is knowing just what is and is not inherited bythe child.  This list can vary depending on Unix implementation, so takeit with a grain of salt.  Note that the child gets <EM>copies</EM> of thesethings, not the real thing.</P><P>Inherited by the child from the parent:</P><UL><LI>process credentials (real/effective/saved UIDs and GIDs)<LI>environment<LI>stack<LI>memory<LI>open file descriptors (note that the underlying file positions areshared between the parent and child, which can be confusing)<LI>close-on-exec flags<LI>signal handling settings<LI>nice value<LI>scheduler class<LI>process group ID<LI>session ID<LI>current working directory<LI>root directory<LI>file mode creation mask (umask)<LI>resource limits<LI>controlling terminal</UL><P>Unique to the child:</P><UL><LI>process ID<LI>different parent process ID<LI>Own copy of file descriptors and directory streams.<LI>process, text, data and other memory locks are NOT inherited.<LI>process times, in the tms struct<LI>resource utilizations are set to 0<LI>pending signals initialized to the empty set<LI>timers created by timer_create not inherited<LI>asynchronous input or output operations not inherited</UL><H2>Zombie processes:  Why you <CODE>wait</CODE> on children.</H2><H3>What is a zombie?</H3><P>When a program forks and the child finishes before the parent, thekernel still keeps some of its information about the child in case theparent might need it -- for example, the parent may need to check thechild's exit status.  To be able to get this information, the parentcalls <CODE>wait()</CODE>; when this happens, the kernel can discard theinformation.</P><P>In the interval between the child terminating and the parent calling<CODE>wait()</CODE>, the child is said to be a `zombie'.  (If you do <CODE>ps</CODE>, thechild will have a `Z' in its status field to indicate this.)  Eventhough it's not running, it's still taking up an entry in the processtable.  </P><P>This is not good, as the process table has a fixed number of entries andit is possible for the system to run out of them. Even if the systemdoesn't run out, there is a limit on the number of processes each usercan run, which is usually smaller than the system's limit. </P><P>If the parent terminates without calling <CODE>wait</CODE>, the child is `adopted'by <CODE>init</CODE>, which handles the work necessary to cleanup after thechild.  (This is a special system program with process ID 1 -- it'sactually the first program to run after the system boots up).</P><H3>Preventing your children from becoming Zombies.</H3><P>You need to ensure that your parent process calls <CODE>wait</CODE> (or<CODE>waitpid</CODE>) for every child process thatterminates.</P><P>Another approach is to <CODE>fork</CODE> <EM>twice</EM>, and have theimmediate child process exit straight away. This causes the grandchildprocess to be orphaned, so the init process is responsible for cleaningit up.</P><P>You can ignore your children's exit states, using signal handling (this gives you anexample using <CODE>sigaction</CODE>; test yourself by trying to use <CODE>signal</CODE>to ignore the signal <CODE>SIGCHLD</CODE>:</P><PRE>    struct sigaction sa;    sa.sa_handler = SIG_IGN;    sa.sa_flags = SA_NOCLDWAIT;    sigemptyset(&#38;sa.sa_mask);    sigaction(SIGCHLD, &#38;sa, NULL);</PRE><P>If you do this do not call <CODE>wait</CODE>: it will not work!!You will wait until <EM>all</EM>child processes have terminated, then return failure with <CODE>errno</CODE>,</CODE>ECHILD</CODE> being set.</P><P>Another technique is to catch the SIGCHLD signal, and have the signalhandler call <CODE>wait</CODE></P>