<html><head><title>Automating Program Compilation - Writing Makefiles</title></head><body><p align=center><img src=http://www.actcom.co.il/~choo/lupg/images/lupg_toolbar.gif height=40 width=360 alt="" usemap="#lupg_map"><map name=lupg_map><area shape=rect coords="3,0 37,39" href=http://www.actcom.co.il/~choo/lupg alt="LUPG home"><area shape=rect coords="67,0 102,39" href=http://www.actcom.co.il/~choo/lupg/tutorials/index.html alt="Tutorials"><area shape=rect coords="138,0 170,39" href=http://www.actcom.co.il/~choo/lupg/related-material.html alt="Related material"><area shape=rect coords="213,0 232,39" href=http://www.actcom.co.il/~choo/lupg/project-ideas/index.html alt="Project Ideas"><area shape=rect coords="272,0 290,39" href=http://www.actcom.co.il/~choo/lupg/essays/index.html alt="Essays"><area shape=rect coords="324,0 355,39" href=mailto:choo@actcom.co.il alt="Send comments"></map><br>[<a href=http://www.actcom.co.il/~choo/lupg/index.html>LUPG Home</a>]  [<a href=http://www.actcom.co.il/~choo/lupg/tutorials/index.html>Tutorials</a>]  [<a href=http://www.actcom.co.il/~choo/lupg/related-material.html>Related Material</a>] [<a href=http://www.actcom.co.il/~choo/lupg/essays/index.html>Essays</a>] [<a href=http://www.actcom.co.il/~choo/lupg/project-ideas/index.html>Project Ideas</a>] [<a href=mailto:choo@actcom.co.il>Send Comments</a>]<br><img src=http://www.actcom.co.il/~choo/lupg/images/good_bar.gif alt=""></p> v1.0.1<h1>Automating Program Compilation - Writing Makefiles</h1>Table Of Contents:<ol><li> <a href="#preface">Preface</a><li> <a href="#makefile_structure">The Structure Of A Makefile</a><li> <a href="#makefile_order">Order Of Compilation</a><li> <a href="#makefile_single_source">Starting Small - A Single-Source Makefile Example</a><li> <a href="#makefile_multiple_source">Getting Bigger - A Multi-Source Makefile Example</a><li> <a href="#makefile_flags">Using Compiler And Linker Flags</a><li> <a href="#makefile_multi_rules">A Rule For Everyone - Using "File Type" Rules</a><li> <a href="#makefile_depends">Automatic Creation Of Dependencies</a></ol><hr size=4><a name="preface"><font color=brown><h2>Preface</h2></font></a><p>Compiling a program made of one source file is easy. Compiling one madeof few sources is slightly annoying, but may be automated via a simple shellscript. Anything larger than that would start to get on your nerves. This iswhere makefiles are helpful.</p><p>A makefile is a collection of instructions that should be used to compile your program.Once you modify some source files, and type the command "make" (or "gmake"if using GNU's make), your program will be recompiled using as fewcompilation commands as possible.Only the files you modified and those dependent upon them will be recompiled.Of-course, this is not done via usage of magic. You need to supply the rulesfor compiling various files and file types, and the list of dependenciesbetween files (if file "A" was changed, then files "B", "C" and "D" also need to be re-compiled), but that only has to be done once.</p><hr size=4><a name="makefile_structure"><font color=brown><h2>The Structure Of A Makefile</h2></font></a><p>A typical makefile contains lines of the following types:<ul><li> <u>Variable Definitions</u> - these lines define values for variables.     For example:     <br>     <pre><code>     CFLAGS = -g -Wall     SRCS = main.c file1.c file2.c     CC = gcc     </code></pre>     <br><li> <u>Dependency Rules</u> - these lines define under what conditions a     given file (or a type of file) needs to be re-compiled, and how to     compile it. For example:     <br>     <pre><code>     main.o: main.c             gcc -g -Wall -c main.c     </code></pre>     <br>     This rule means that "main.o" has to be recompiled whenever "main.c" is     modified. The rule continues to tell us that in order to compile     "main.o", the command <code>"gcc -g -Wall -c main.c"</code> needs to     be executed.<br>     Note that each line in the commands list must begin with     a TAB character. "make" is quite picky about the makefile's syntax.     <br><br><li> <u>Comments</u> - Any line beginning with a "#" sign, or any line     that contains only white-space.</ul></p><hr size=4><a name="makefile_order"><font color=brown><h2>Order Of Compilation</h2></font></a><p>When a makefile is executed, we tell the <code>make</code> command to compile aspecific target. A target is just some name that appears at the beginningof a rule. It can be a name of a file to create, or just a name thatis used as a starting point (such a target is also called a "phony" target).</p><p>When <code>make</code> Is invoked, it first evaluates all variable assignments,from top to bottom, and when it encounters a rule "A" whose target matches thegiven target (or the first rule, if no target was supplied), it tries toevaluate this rule. First, it tries to recursively handle the dependenciesthat appear in the rule. If a given dependency has no matching rule, but thereis a file in the disk with this name, the dependency is assumed to beup-to-date. After all the dependencies were checked, and any of themrequired handling, or refers to a file newer than the target, the command listfor rule "A" is executed, one command at a time.</p><p>This might appear a little complex, but the example in the next section willmake things clear.</p><hr size=4><a name="makefile_single_source"><font color=brown><h2>Starting Small - A Single-Source Makefile Example</h2></font></a><p>Lets first see a simple example of a makefile that is used to compile a programmade of a single source file:</p><p><pre><code><font color=brown># top-level rule to create the program.</font>all: main<font color=brown># compiling the source file.</font>main.o: main.c        gcc -g -Wall -c main.c<font color=brown># linking the program.</font>main: main.o        gcc -g main.o -o main<font color=brown># cleaning everything that can be automatically recreated with "make".</font>clean:        /bin/rm -f main main.o</code></pre></p><p>Few notes about this makefile:<ol><li> Not all rules have to be used in every invocation of     <code>make</code>. The "clean" rule, for example, is not normally used     when building the program, but it may be used to remove the object     files created, to save disk space.<li> A rule doesn't need to have any dependencies. This means if we tell make     to handle its target, it will always execute its commands list, as in     the "clean" rule above.<li> A rule doesn't need to have any commands. For example, the "all" rule     is just used to invoke other rules, but does not need any commands of     its own. It is just convenient to make sure that if someone runs     <code>make</code> without a target name, this rule will get executed, due     to being the first rule encountered.<li> We used the full path to the "rm" command, instead of just typing "rm",     because many users have this command aliased to something else (for     example, "rm" aliased to "rm -i"). By using a full path, we avoid any     aliases.</ol></p><hr size=4><a name="makefile_multiple_source"><font color=brown><h2>Getting Bigger - A Multi-Source Makefile Example</h2></font></a><p>In anything but the simplest programs, we usually have more than one source file.This is where using a makefile starts to pay off. Making a change to one filerequires re-compilation of only the modified file, and then re-linking theprogram. Here is an example of such a makefile:</p><p><pre><code><font color=brown># top-level rule to compile the whole program.</font>all: prog<font color=brown># program is made of several source files.</font>prog: main.o file1.o file2.o        gcc main.o file1.o file2.o -o prog<font color=brown># rule for file "main.o".</font>main.o: main.c file1.h file2.h        gcc -g -Wall -c main.c<font color=brown># rule for file "file1.o".</font>file1.o: file1.c file1.h        gcc -g -Wall -c file1.c<font color=brown># rule for file "file2.o".</font>file2.o: file2.c file2.h        gcc -g -Wall -c file2.c<font color=brown># rule for cleaning files generated during compilations.</font>clean:        /bin/rm -f prog main.o file1.o file2.o</code></pre></p><p>Few notes:<ul><li> There is one rule here for each source file. This causes some redundancy,     but later on we'll see how to get rid of it.<li> We add dependency on included files (file1.h, file2.h) where applicable.     If one of these interface-definition files changes, the files that     include it might need a re-compilation too. This is not always true,     but it is better to make a redundant compilation, than to have object     files that are not synchronized with the source code.</ul></p><hr size=4><a name="makefile_flags"><font color=brown><h2>Using Compiler And Linker Flags</h2></font></a><p>As one could see, there are many repetitive patterns in the rules forour makefile. For example, what if we wanted to change the flags forcompilation, to use optimization (<code>-O</code>), instead of add debuginfo (<code>-g</code>)?  we would need to go and change this flag for eachrule. This might not look like much work with 3 source files, but it will betedious when we have few tens of files, possibly spread over few directories.</p><p>The solution to this problem is usingvariables to store various flags, and even command names. This isespecially useful when trying to compile the same source code with differentcompilers, or on different platforms, where even a basic command such as "rm"might reside in a different directory on each platform.</p><p>Lets see the same makefile, but this time with the introduction of variables:</p><p><pre><code><font color=brown># use "gcc" to compile source files.</font>CC = gcc<font color=brown># the linker is also "gcc". It might be something else with other compilers.</font>LD = gcc<font color=brown># Compiler flags go here.</font>CFLAGS = -g -Wall<font color=brown># Linker flags go here. Currently there aren't any, but if we'll switch to</font><font color=brown># code optimization, we might add "-s" here to strip debug info and symbols.</font>LDFLAGS =<font color=brown># use this command to erase files.</font>RM = /bin/rm -f<font color=brown># list of generated object files.</font>OBJS = main.o file1.o file2.o<font color=brown># program executable file name.</font>PROG = prog<font color=brown># top-level rule, to compile everything.</font>all: $(PROG)<font color=brown># rule to link the program</font>$(PROG): $(OBJS)        $(LD) $(LDFLAGS) $(OBJS) -o $(PROG)<font color=brown># rule for file "main.o".</font>main.o: main.c file1.h file2.h        $(CC) $(CFLAGS) -c main.c<font color=brown># rule for file "file1.o".</font>file1.o: file1.c file1.h        $(CC) $(CFLAGS) -c file1.c<font color=brown># rule for file "file2.o".</font>file2.o: file2.c file2.h        $(CC) $(CFLAGS) -c file2.c<font color=brown># rule for cleaning re-compilable files.</font>clean:        $(RM) $(PROG) $(OBJS)</code></pre></p><p>Few notes:<ul><li> We define many variables in this makefile. This will make it very easy     to modify compile flags, compiler used, etc. It is good practice to      define even things that might seem like they'll never change. In time -     they will.<li> We still have a problem with the fact that we define one rule for each     source file. If we'll want to change this rule's format, it will be     rather tedious. The next section will show us how to avoid this problem.</ul></p><hr size=4><a name="makefile_multi_rules"><font color=brown><h2>A Rule For Everyone - Using "File Type" Rules</h2></font></a><p>So, the next phase would be to eliminate the redundant rules, and try to useone rule for all source files. After all, they are all compiled in thesame way. Here is a modified makefile:</p><p><pre><code><font color=brown># we'll skip all the variable definitions, just take them from the previous</font><font color=brown># makefile</font>..<font color=brown># linking rule remains the same as before.</font>$(PROG): $(OBJS)        $(LD) $(LDFLAGS) $(OBJS) -o $(PROG)<font color=brown># now comes a meta-rule for compiling any "C" source file.</font>%.o: %.c        $(CC) $(CFLAGS) -c $&lt;</code></pre></p><p>We should explain two things about our meta-rule:<ol><li> The "%" character is a wildcard, that matches any part of a file's name.     If we mention "%" several times in a rule, they all must match the same     value, for a given rule invocation. Thus, our rule here means "A file     with a '.o' suffix is dependent on a file with the same name, but a '.c'     suffix".<li> The "$&lt;" string refers to the dependency list that was matched by the     rule (in our case - the full name of the source file).     There are other similar strings, such as "$@" which refers to the full     target name, or "$*", that refers the part that was matched by the     "%" character.</ol></p><hr size=4><a name="makefile_depends"><font color=brown><h2>Automatic Creation Of Dependencies</h2></font><p>One problem with the usage of implicit rules, is that we lost the fulllist of dependencies, that are unique to each file. This can be overcomeby using extra rules for each file, that only contain dependencies, but nocommands. This can be added manually, or be automated in one of various ways.Here is one example, using the "makedepend" Unix program.</p><p><pre><code><font color=brown># define the list of source files.</font>SRCS = main.c file1.c file2.c..<font color=brown># most of the makefile remains as it was before.</font><font color=brown># at the bottom, we add these lines:</font><font color=brown># rule for building dependency lists, and writing them to a file</font><font color=brown># named ".depend".</font>depend:        $(RM) .depend        makedepend -f- -- $(CFLAGS) -- $(SRCS) > .depend<font color=brown># now add a line to include the dependency list.</font>include .depend</code></pre></p><p>Now, if we run "make depend", the "makedepend" program will scan the givensource files, create a dependency list for each of them, and write appropriaterules to the file ".depend". Since this file is then included by the makefile,when we'll compile the program itself, these dependencies will be checkedduring program compilation.</p><p>There are many other ways to generate dependency lists. It is advised thatprogrammers interested in this issue read about the compiler's "-M"flag, and read the manual page of "makedepend" carefully. Also note that gnumake's info pages suggest a different way of making dependency lists created automatically when compiling a program. The advantage is that thedependency list never gets out of date. The disadvantage is that many timesit is being run for no reason, thus slowing down the compilation phase. Onlyexperimenting will show you exactly when to use each approach.</p><hr size=4><p align=center><img src=http://www.actcom.co.il/~choo/lupg/images/lupg_toolbar.gif height=40 width=360 alt="" usemap="#lupg_map"><map name=lupg_map><area shape=rect coords="3,0 37,39" href=http://www.actcom.co.il/~choo/lupg alt="LUPG home"><area shape=rect coords="67,0 102,39" href=http://www.actcom.co.il/~choo/lupg/tutorials/index.html alt="Tutorials"><area shape=rect coords="138,0 170,39" href=http://www.actcom.co.il/~choo/lupg/related-material.html alt="Related material"><area shape=rect coords="213,0 232,39" href=http://www.actcom.co.il/~choo/lupg/project-ideas/index.html alt="Project Ideas"><area shape=rect coords="272,0 290,39" href=http://www.actcom.co.il/~choo/lupg/essays/index.html alt="Essays"><area shape=rect coords="324,0 355,39" href=mailto:choo@actcom.co.il alt="Send comments"></map><br>[<a href=http://www.actcom.co.il/~choo/lupg/index.html>LUPG Home</a>]  [<a href=http://www.actcom.co.il/~choo/lupg/tutorials/index.html>Tutorials</a>]  [<a href=http://www.actcom.co.il/~choo/lupg/related-material.html>Related Material</a>] [<a href=http://www.actcom.co.il/~choo/lupg/essays/index.html>Essays</a>] [<a href=http://www.actcom.co.il/~choo/lupg/project-ideas/index.html>Project Ideas</a>] [<a href=mailto:choo@actcom.co.il>Send Comments</a>]<br><img src=http://www.actcom.co.il/~choo/lupg/images/good_bar.gif alt=""></p> <p>This document is copyright (c) 1998-2002 by guy keren.<br><br>The material in this document is provided AS IS, without anyexpressed or implied warranty, or claim of fitness for aparticular purpose. Neither the author nor any contributers shellbe liable for any damages incured directly or indirectly by usingthe material contained in this document.<br><br>permission to copy this document (electronically or on paper, forpersonal or organization internal use) or publish it on-line ishereby granted, provided that the document is copied as-is, thiscopyright notice is preserved, and a link to the original documentis written in the document's body, or in the page linking to thecopy of this document.<br><br>Permission to make translations of this document is also granted,under these terms - assuming the translation preserves the meaningof the text, the copyright notice is preserved as-is, and a linkto the original document is written in the document's body, or inthe page linking to the copy of this document.<br><br>For any questions about the document and its license, please<a href=mailto:choo@actcom.co.il>contact the author</a>.</p> </body></html>