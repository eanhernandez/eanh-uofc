<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>File I/O</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><center><H1>FILE I/O</H1></center><p><H2>Sources</H2><ul><li>[Molay]&#009;Bruce Molay&#009;	<em>Understanding Unix/Linux Programming</em>, Chapter 2</li><li>[Stevens]&#009; W. Richard Stevens&#009;		<em>Advanced Programming in the UNIX Environment</em>, Chapter 3</li><li><strong>man</strong> <strong>2</strong> <font face="Courier New, Courier, mono">function</font></li></ul>		<H2>Introduction</H2>Most Unix file I/O can be performed with six functions:<ul>	<li><font face="Courier New, Courier, mono">open</font></li>	<li><font face="Courier New, Courier, mono">close</font></li>	<li><font face="Courier New, Courier, mono">read</font></li>	<li><font face="Courier New, Courier, mono">write</font></li>	<li><font face="Courier New, Courier, mono">lseek</font></li>	<li><font face="Courier New, Courier, mono">dup, dup2</font></li></ul>These functions are part of the POSIX standard for UNIX programming, not part of ANSI C (and so, youwill not find reference to them in Harbison and Steele's <em>C Reference Manual</em>.)Unlike the standard I/O routines provided by ANSI C (such as <font face="Courier New, Courier, mono">fscanf</font> and <font face="Courier New, Courier, mono">fprintf</font> which store thedata they read in buffers) these functions are <em>unbuffered</em> I/O.  They invoke a system call inthe kernel, and will be called by the standard ANSI C function calls in the UNIX environment.</p><H2>File Descriptors</H2><p>What happens when a process opens a file? A process may have several open files which it maybe reading from and writing to.  It also has a current position within the file, which is the nextbyte to be read or written.  Each process has its own array to keep track of<ul>     	<li>The file opened.</li>		<li>The files status (whether open for reading or writing:  the			<a href="#file_status">file status flags</a> )</li>		<li>The current offset within the file</li>	</ul>When a file is opened or created by a process the kernel assigns a position in the array calledthe file descriptor.  Each entry of this array actually contains a pointer to a <em>file table</em>which stores each of the three pieces of information:  file, file status flags, and offset. The filetable does not itself contain the file, but instead has a pointer to another table (called the <em>vnodetable</em>), which has vital information about the file, including its location in memory.  The vnodetable is unique for each file.  Why this complicated sequence?:<br><center>file descriptor&nbsp;&nbsp;--->&nbsp;&nbsp;file table&nbsp;&nbsp;--->&nbsp;&nbsp;		vnode table</center><br>It turns out to be very flexible:<ul>	<li>Different processes can have file descriptors for the same file.</li>	<li>A single process can have <a href="#fd_open">several file descriptors</a>		 for the same file through different file tables.</li>	<li>A single process can have <a href="#fd_dup">different file descriptors</a>		 for the same file table.</li>	<li>Different process can have different file descriptors for the same file table. 		(The processes must be related as parent to child, or grandchild.  This involves		 	forking.)</li>	</ul>This flexibility is at the heart of how Unix can implement file redirection (<font face="Courier New, Courier, mono">&lt;</font> and  <font face="Courier New, Courier, mono">&gt;</font>) and pipes (<font face="Courier New, Courier, mono">|</font>). </p><p>The file descriptors are unique to a process (except under certain circumstances), in that the integersmay by reused by another process without referring to the same file or location within a file.  Byconvention Unix shells (although <em>not</em> the kernel) employ the following values:<BR><table width="75%">  <tr>    <td>File</td>    <td>File Descriptor</td>    <td>POSIX Symbolic Constant</td>  </tr>  <tr>    <td>Standard Input</td>    <td>0</td>    <td><font face="Courier New, Courier, mono">STDIN_FILENO</font></td>  </tr>  <tr>    <td>Standard Output</td>    <td>1</td>    <td><font face="Courier New, Courier, mono">STDOUT_FILENO</font></td>  </tr>  <tr>    <td>Standard Error</td>    <td>2</td>    <td><font face="Courier New, Courier, mono">STDERR</font></td>  </tr></table></p> <p>How many file descriptors may be opened by a process?  One complication here is that this may dependupon the available memory for the process, the maximum integer size, or limits set by the systemadministrator.  Its value is potententially unlimited, but guaranteed by POSIX to be at least 16.  Determining the actual value can be difficult, since the value may not be determined at compile time.If a hard limit has been set (so determined at compile time), the symbolic constant OPEN_MAX found in<font face="Courier New, Courier, mono">limits.h</font> will be set; if the limit is determined at runtime a call to <font face="Courier New, Courier, mono">sysconf(_SC_OPEN_MAX)</font> will produce thevalue.  But, it may be indeterminate even at run time (see [Stevens, pp. 42-4] for an alternative todetermine this value.)  POSIX does insist that the value should not change during the processeslifetime.  [Stevens, pp. 33-4, 40, 42-4, 47-8]</p>  <H2>System Calls</H2><p>Remember that everything is a file in Unix.  Because there are so many types of files, several of thesystem calls below will behave slightly differently for files that are not regular. I have notattempted to include the exact behavior, or all the errors that can arise for files which are notregular.</p><H3>open</H3><table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">open</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td>Purpose</td>    <td>open or create a file for reading or writing</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;fcntl.h&gt;</font><br>		&nbsp;&nbsp;&nbsp;&nbsp;If the optional third argument is used also include:<br>		<font face="Courier New, Courier, mono">#include&lt;sys/types.h&gt;</font><br>		<font face="Courier New, Courier, mono">#include&lt;sys/stat.h&gt;</font>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">int open(const char *path, int flags[, mode_t mode]);			</font><br> (The third argument is optional.)</td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">path</font>:  &nbsp;&nbsp;			the (relative) path to the file<br>		<font face="Courier New, Courier, mono">flags</font>:  &nbsp;&nbsp;the		 <a href="#file_status">file status flags</a><br>		<font face="Courier New, Courier, mono">mode</font>:&nbsp;&nbsp;file permissions,		used when creating a new file</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		file descriptor on success	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td>Too numerous to list all:  see <strong>man 2 open</strong><br>		<font face="Courier New, Courier, mono">ENOTDIR</font>:&nbsp;&nbsp;			A component of the path prefix is not a directory.<br>		<font face="Courier New, Courier, mono">EACCES</font>: &nbsp;&nbsp;				Permissions do not permit reading or writing<br>		<font face="Courier New, Courier, mono">EISDIR</font>: &nbsp;&nbsp;				The named file is a directory and it is to opened for writing.<br>		<font face="Courier New, Courier, mono">EMFILE</font>: &nbsp;&nbsp;	The process has already reached its limit for open file descriptors.</td>  </tr></table><p>The file descriptor returned by open is guaranteed to be the lowest numbered  unused descriptor. This is valuable to know when you want to redirect to a  regular file the input to a command that expects to read standard input (or  write to standard output): To redirect standard input simply close<font face="Courier New, Courier, mono">STDIN_FILENO</font> (descriptor 0) then <font face="Courier New, Courier, mono">open</font> a new file--which will begiven descriptor 0.</p><p>The values for the second argument, the file status flags <a name="file_status"></a>  consists of bitwise OR'ing ('|') the following:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One of these three <strong>must</strong> be included:<table width="75%" border="1">  <tr>    <td><font face="Courier New, Courier, mono">O_RDONLY</font></td>    <td>open for reading only</td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">O_WRONLY</font></td>    <td>open for writing only</td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">O_RDWR</font></td>    <td>open for reading and writing</td>  </tr></table><p><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  The following are optional arguments </p><table width="75%" border="1">  <tr>    <td><font face="Courier New, Courier, mono">O_APPEND</font></td>    <td>append on each write</td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">O_CREAT</font></td>    <td>create file if it does not exist: REQUIRES <a href="#mode">mode</a></td>  </tr>  <tr>    <td><font face="Courier New, Courier, mono">O_TRUNC</font></td>    <td>truncate size to 0</td>  </tr></table><br>There are four other options, but these three are the most useful, for now. See [Stevens, p.49] for a description of all options. </p><p><a name="mode"></a>The value for <em>mode</em> <strong>must</strong> be included when <font face="Courier New, Courier, mono">O_CREAT</font> is set.  It is simply the permissions, andcan be written using C's <em>octal</em> representation (this is base eight and starts with a leadingzero.)  For example, to request that you (the creator) have read and write privileges and everyoneelse have read privileges only, you would specify<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">open("<em>pathtofile</em>",O_WRONLY |O_CREAT, 0644);<br><br></font>This is only a request on your part, and this request will be compared with the<font face="Courier New, Courier, mono">umask</font> to determine the final permissions of the file.See especially [Molay, pp. 84-8], or [Stevens, p.78-81]for further details.</p><p><a name="fd_open"></a>Notice how <font face="Courier New, Courier, mono">open</font> allows a process to have different filedescriptors to the same file.  These may have different file status flags, and may even have differentoffsets within the file.</p><H3>close</H3><p><font face="Courier New, Courier, mono">close</font> is used to detach the use of the file descriptorfor a process.  When a process terminates any open file descriptors areautomatically closed by the kernel.<table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">close</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td>Purpose</td>    <td>delete a file descriptor</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;unistd.h&gt;</font>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">int close(int d);</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">d</font>:  &nbsp;&nbsp;			a file descriptor	</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		0 on success (the file descriptor deleted)	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td><font face="Courier New, Courier, mono">EBADF</font>:&nbsp;&nbsp;			<font face="Courier New, Courier, mono">d</font> is not an active descriptor.<br>		<font face="Courier New, Courier, mono">EINTR</font>: &nbsp;&nbsp;				An interrupt was received.	</td>  </tr></table></p><H3>read</H3><p><font face="Courier New, Courier, mono">read</font> starts at the file's current offset, which is thenoffset by the number of bytes read (for regular files.)<table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">read</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td>Purpose</td>    <td>read input from file</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;unistd.h&gt;</font><br>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">ssize_t read(int d, void *buf, size_t nbytes);			</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">d</font>:  &nbsp;&nbsp;			a file descriptor<br>		<font face="Courier New, Courier, mono">buf</font>:  &nbsp;&nbsp;			buffer for storing bytes read<br>		<font face="Courier New, Courier, mono">nbytes</font>:  &nbsp;&nbsp;			maximum number of bytes to read			</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		number of bytes read and placed in <font face="Courier New, Courier, mono">buf</font> or		0 if end of file			</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td><font face="Courier New, Courier, mono">EBADF</font>:&nbsp;&nbsp;			<font face="Courier New, Courier, mono">d</font> is not an active descriptor..<br>		<font face="Courier New, Courier, mono">EFAULT</font>: &nbsp;&nbsp;				<font face="Courier New, Courier, mono">buf</font>				 points outside the allocated address space.<br>		<font face="Courier New, Courier, mono">EAGAIN</font>: &nbsp;&nbsp;				The file was marked for non-blocking I/O, and no data were ready to be read.<br>		<font face="Courier New, Courier, mono">EINVAL</font>: &nbsp;&nbsp;				The pointer associated with <font face="Courier New, Courier, mono">d</font>					 was negative.<br> 		<font face="Courier New, Courier, mono">EIO</font>: &nbsp;&nbsp;				An I/O error occurred while reading from the file system.	</td>  </tr></table><br>The main reason the number of bytes read may be less than the number of bytes requested innbytes is that the end of the file was reached before the requested number of bytes has been read.See [Stevens, p. 54] for several other reasons involving other types of files.</p><H3>write</H3><p><font face="Courier New, Courier, mono">write</font> starts at the file's current offset, which is thenoffset by the number of bytes written to the file (for regular files.)<table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">write</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td>Purpose</td>    <td>write output to file</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;unistd.h&gt;</font><br>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">ssize_t write(int d, void *buf, size_t nbytes);			</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">d</font>:  &nbsp;&nbsp;			a file descriptor<br>		<font face="Courier New, Courier, mono">buf</font>:  &nbsp;&nbsp;			buffer for storing bytes to be written<br>		<font face="Courier New, Courier, mono">nbytes</font>:  &nbsp;&nbsp;			maximum number of bytes to read			</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		number of bytes written 	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td>Too numerous to list all:  see <strong>man 2 write</strong><br>		<font face="Courier New, Courier, mono">EBADF</font>:&nbsp;&nbsp;			<font face="Courier New, Courier, mono">d</font> is not an active descriptor.<br>				<font face="Courier New, Courier, mono">EFAULT</font>: &nbsp;&nbsp;		Data to be written to the file points outside the allocated address space.<br>		<font face="Courier New, Courier, mono">EINVAL</font>: &nbsp;&nbsp;				The pointer associated with <font face="Courier New, Courier, mono">d</font>					 was negative.<br>				<font face="Courier New, Courier, mono">EFBIG</font>: &nbsp;&nbsp;				An attempt was made to write a file that exceeds the				process's file size limit or the maximum file size.<br>		<font face="Courier New, Courier, mono">ENOSPC</font>: &nbsp;&nbsp;				There is no free space remaining on the file system					containing the file..<br>				<font face="Courier New, Courier, mono">EAGAIN</font>: &nbsp;&nbsp;				The file was marked for non-blocking I/O, and no data were ready to be read.<br>		<font face="Courier New, Courier, mono">EINTR</font>: &nbsp;&nbsp;				A signal interrupted the write before it could be completed.<br>		 		<font face="Courier New, Courier, mono">EIO</font>: &nbsp;&nbsp;				An I/O error occurred while reading from the file system.	</td>  </tr></table></p><H3>lseek</H3><p>Every file descriptor has an associated <em>current file offset</em>, a number of bytes from thebeginning of the file.  Read and write operations normally start at the current offset and cause the offset to be incremented the number of bytes read or written.<font face="Courier New, Courier, mono">lseek</font> explicitly repositions this offset value.<br><table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">lseek</font></td>    <td>&nbsp;</td>  </tr>  <tr>    <td>Purpose</td>    <td>reposition read/write file offset</td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;unistd.h&gt;</font><br>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono">off_t lseek(int d, off_t offset, int base);</font> </font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td><font face="Courier New, Courier, mono">d</font>:  &nbsp;&nbsp;			a file descriptor<br>		<font face="Courier New, Courier, mono">offset</font>:  &nbsp;&nbsp;			the number of bytes to be offset<br>		<font face="Courier New, Courier, mono">base</font>:  &nbsp;&nbsp;			the position from which the bytes will be offset:<br>		&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">SEEK_SET</font>:  &nbsp;&nbsp;			<font face="Courier New, Courier, mono">offset</font> bytes from beginning of the file.<br>		&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">SEEK_CUR</font>:  &nbsp;&nbsp;			<font face="Courier New, Courier, mono">offset</font> bytes from current value of offset.<br>		&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">SEEK_END</font>:  &nbsp;&nbsp;			<font face="Courier New, Courier, mono">offset</font> bytes from end of the file.												</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		The resulting offset location as measured in bytes from the beginning of the file.			</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td><font face="Courier New, Courier, mono">EBADF</font>:&nbsp;&nbsp;			<font face="Courier New, Courier, mono">d</font> is not an active descriptor..<br>		<font face="Courier New, Courier, mono">EINVAL</font>: &nbsp;&nbsp;				<font face="Courier New, Courier, mono">base</font>not a proper value.<br> 		<font face="Courier New, Courier, mono">ESPIPE</font>: &nbsp;&nbsp;				<font face="Courier New, Courier, mono">base</font> associated with a non-regular				file (pipe, socket or FIFO.)	</td>  </tr></table><br>A file's offset can be greater than its current size.  In this case, if the file is then writtento it creates holes in the file, whose value is '\0'.  A regular file may not be offset before thebeginning of the file</p><p><font face="Courier New, Courier, mono">lseek</font> can be used to determine the current offset<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		<font face="Courier New, Courier, mono">off_t &nbsp;&nbsp; currpos;</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	<font face="Courier New, Courier, mono">ccurrpos = lseek(fd, 0, SEEK_CUR);</font><br><br><font face="Courier New, Courier, mono">lseek</font> can also be used to test a file descripter if it is a pipe, FIFO, or socket, since these are notcapable of seeking:  they force a return of -1 and set errno to<font face="Courier New, Courier, mono">ESPIPE</font>. 	</p><H2>creat</H2><font face="Courier New, Courier, mono">creat</font> opens a file for writing, creating a new fileif one did not exist, or truncating the current file, discarding its contents, if a file does exist.Actually, <font face="Courier New, Courier, mono">creat</font> is now implemented by <font face="Courier New, Courier, mono">open</font>.  Its prototype, together with the necessaryheader file is:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		<font face="Courier New, Courier, mono">#include&lt;fcntl.h&gt;</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		<font face="Courier New, Courier, mono">int creat(const char *path, mode_t mode);</font><br>but is implemented as<br>		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	<font face="Courier New, Courier, mono">	open(path, O_CREAT | O_TRUNC | O_WRONLY, mode);</font>	<H3>dup and dup2</H3><a name="fd_dup"></a><font face="Courier New, Courier, mono">dup</font> and <font face="Courier New, Courier, mono">dup2</font> duplicate the contents ofan existing file descriptor. Remember, a file descriptor is the index of an arraywhich contains a pointer to the filetable.  These functions allow a second file descriptor to index a pointer tothe same file table. The difference is that <font face="Courier New, Courier, mono">dup</font> takesa single argument, the file descriptor you want to duplicate, and returns a new file descriptor whichis guaranteed to be the lowest available.  <font face="Courier New, Courier, mono">dup2</font> givesyou more control over the new file descriptor:  it takes two arguments, an already opened filedescriptor and a new file descriptor, and directs the new file descriptor to point to the same filetable.  This is especially valuable when we want to create pipes between programs.  If the new filedescriptor is actually being used, <font face="Courier New, Courier, mono">dup2</font> closes thefile descriptor first, then reassigns it; if the two file descriptors are the same, nothing occurs.<br><br><table width="99%" border="1" rules="all">  <tr>    <td><font face="Courier New, Courier, mono">dup</font><br>		<font face="Courier New, Courier, mono">dup2</font>	</td>    <td>&nbsp;</td>  </tr>  <tr>    <td valign="top">Purpose </td>    <td>duplicate an existing file descriptor </td>  </tr>  <tr>    <td valign="top">Include</td>    <td><font face="Courier New, Courier, mono">#include&lt;unistd.h&gt;</font><br>	</td>  </tr>  <tr>    <td valign="top">Useage</td>    <td> <font face="Courier New, Courier, mono"> int dup(int oldd);</font><br>		  <font face="Courier New, Courier, mono"> int dup2(int oldd, int newd);</font></td>  </tr>  <tr>    <td valign="top">Arguments</td>    <td> <font face="Courier New, Courier, mono">oldd</font>:  &nbsp;&nbsp; 			an existing file descriptor<br>		<font face="Courier New, Courier, mono">newd</font>:  &nbsp;&nbsp; 		the value of the new descriptor newd</td>  </tr>  <tr>    <td valign="top">Returns</td>    <td>-1 on error<br>		the value of <font face="Courier New, Courier, mono">newd</font>	</td>  </tr>  <tr>    <td valign="top">Errors</td>    <td><font face="Courier New, Courier, mono">EBADF</font>:&nbsp;&nbsp;			<font face="Courier New, Courier, mono">oldd</font> or 			<font face="Courier New, Courier, mono">newd</font> is not a valid active descriptor<br>		<font face="Courier New, Courier, mono">EMFILE</font>:&nbsp;&nbsp;			Too many descriptors are active.</td>  </tr></table>