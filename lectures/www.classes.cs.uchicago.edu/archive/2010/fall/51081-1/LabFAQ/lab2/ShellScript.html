<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head><title>Shell Scripts</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><h1>Shell Scripts</h1><h3>The Problem</h3><p>  You have a thousand C files in your directory  (these end in '.c' byconvention) and you need to correct a typo made in these files.  You can solvethis problem with a few simple lines of code.</p><h3>Changing one file:  Using <font face="Courier New, Courier, mono">ed</font></h3><p>  Consider the simplest problem:  making the changes in one file.  You can do it by hand,   but this can only be automated at an extreme cost to yourself.  We'll use the   command <font face="Courier New, Courier, mono">ed</font> to do the job for us.  The manual pages say  that <font face="Courier New, Courier, mono">ed</font> is <em>a line-oriented text editor</em>:  this means  it reads each line of a text file and performs a sequence of actions modifying the text.  It then stores  the line in a buffer, and will only rewrite the file if the user requests the changes to the file are  saved.  <font face="Courier New, Courier, mono">ed</font> is unusual in that it accepts its commands  from standard input--which will be your keyboard if you type <br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font face="Courier New, Courier, mono">ed</font>&nbsp;&nbsp;<em>file</em><br>  you will recieve a blank line:  <font face="Courier New, Courier, mono">% ed</font> is expecting input.  Typing <font face="Courier New, Courier, mono">q</font> will move you out of  <font face="Courier New, Courier, mono">ed</font> and back to the shell prompt.  A typical session with  <font face="Courier New, Courier, mono">ed</font> will look as follows:<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font face="Courier New, Courier, mono">% ed</font>&nbsp;&nbsp;<em>file</em><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">27</font><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>comand</em><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>comand</em><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>comand</em><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">w</font><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">q</font><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">25</font><br>	The <font face="Courier New, Courier, mono">w</font> tells <font face="Courier New, Courier, mono">ed</font>to save your changes back to the file.  The number that is displayed before the first <em>command</em>  is the number of bytes in <em>file</em>, the last number is the number of bytes now in <em>file</em> after it was edited.  These are <font face="Courier New, Courier, mono">% ed</font>'s response to you.  You can learn about the commands <font face="Courier New, Courier, mono">ed</font> excepts from the  <a href="../introlab/manpage.html">manual pages</a>.</p>    <h3>Automating <font face="Courier New, Courier, mono">ed</font> from Here </h3><p>     Do you see a problem with using <font face="Courier New, Courier, mono">ed</font>?  It has not savedmuch time over manually opening-up each document.  The Bash shell provides a nice facility that providesthe needed bridge:  we can redirect standard input to read from Here (wherever that may be.)  Here is anexample:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">% ed</font>&nbsp;&nbsp;<em>file</em>		<font face="Courier New, Courier, mono">&nbsp;&nbsp;&lt;&lt;TEXT</font><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<em>comand</em><br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<em>comand</em><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<em>comand</em><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<font face="Courier New, Courier, mono">w</font><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<font face="Courier New, Courier, mono">q</font><br>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;<font face="Courier New, Courier, mono">TEXT</font><br>  Notice that there is no response from <font face="Courier New, Courier, mono">ed</font>   until the final <font face="Courier New, Courier, mono">TEXT</font> is typed;   also there is now a prompt <font face="Courier New, Courier, mono">&gt;</font>   displayed. When you add <font face="Courier New, Courier, mono">&lt;&lt;TEXT</font>   to the end of a command, Bash will wait for you to type some text, then direct   your text to standard input for the command; you inform Bash you are finished   by typing <font face="Courier New, Courier, mono">TEXT</font>. </p>  <h3> Using Here to Solve the Problem over There</h3><p>     The redirection is cute, but so far it still requires you to be Here at the keyboard.  The key though	 is that you no longer need to be at the keyboard to feed commands to 	 <font face="Courier New, Courier, mono">ed</font>:  you could be anywhere.  You can open-up a file 	 (lets call it <em>myscript</em>) 	  and type:<br><br>  <font face="Courier New, Courier, mono">ed</font>&nbsp;&nbsp;<em>file</em> <font face="Courier New, Courier, mono">&nbsp;&nbsp;&lt;&lt;TEXT</font><br>    <em>comand</em><br>    <em>comand</em><br>	<em>comand</em><br>	<font face="Courier New, Courier, mono">w</font><br>	<font face="Courier New, Courier, mono">q</font><br>	<font face="Courier New, Courier, mono">TEXT</font><br><br>		To execute the contents of the file, you simple type on the command line<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">% bash</font>&nbsp;&nbsp;<em>myscript</em><br>and voil&agrave;, you have executed the commands to <font face="Courier New, Courier, mono">ed</font>from a file, not your keyboard.	 You now have your first shell script. </p>   <h3>Shell Scripting:  Bring out the Heavy Artillery</h3> <p> I have been steering you along, but we still do not seem to be any closer to solving our problem of editing 1000 files.  Our "script" requires that we change the script for each file in our directory we want to change.  Then we must type a command on the prompt to execute this.  Very true.  Now, lets bring-out the heavy cannonade:  <em>loops</em> and <em>variables</em>.  The Bash shell can be programed to automate this process by adding a couple of lines to our script:<br><br>  <font face="Courier New, Courier, mono">for file in *.c</font><br> &nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">do</font><br>  <font face="Courier New, Courier, mono">ed&nbsp;$file &nbsp;&lt;&lt;TEXT</font><br>    <em>comand</em><br>    <em>comand</em><br>	<em>comand</em><br>	<font face="Courier New, Courier, mono">w</font><br>	<font face="Courier New, Courier, mono">q</font><br>	<font face="Courier New, Courier, mono">TEXT</font><br> &nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">done</font><br><br>	 The first line of code tells Bash that <font face="Courier New, Courier, mono">for</font> each of our <em>files</em> ending in ".c" in the current directory, <font face="Courier New, Courier, mono">do</font> the following routine, until you reach <font face="Courier New, Courier, mono">done</font>.  In the Bash shell variables begin with '$', as in <font face="Courier New, Courier, mono">$file</font>. Now, when we type:<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier New, Courier, mono">% bash</font>&nbsp;&nbsp;<em>myscript</em><br>  Bash will make the changes to every one of our thousand files. </p>  <h3>Making a Script File Act like a Command</h3> <p> This last section is for simple aesthetics:  we do not need to type  <font face="Courier New, Courier, mono">bash</font> every time we want to run our script.  Suppose  we want to re-use the script, do we really want to remember that we have to run it using  <font face="Courier New, Courier, mono">bash</font>?   You can use the following simple steps to convert  your <font face="Courier New, Courier, mono">bash</font> or any other script such as a   <font face="Courier New, Courier, mono">gawk</font> script to a simple command:<br>  <ol>      <li>Find out the location of the executable file for <font face="Courier New, Courier, mono">bash</font>     (or <font face="Courier New, Courier, mono">gawk</font>):<br>		 &nbsp;&nbsp;<font face="Courier New, Courier, mono"> which bash</font></li>   	<li>  On the <strong>first</strong> line of your script add:<br>	&nbsp;&nbsp;<font face="Courier New, Courier, mono">#!/bin/bash</font><br>	  or whatever location was returned to you from step 1. When you execute a text file, the  	   shell will look at the first line to see what program must be called to interpret the file.	   This could be the shell itself, or any other program 	   (like <font face="Courier New, Courier, mono">gawk</font>) which can read a scripting	    language.)</li>	<li>Make your file executable:  you will need to give <em>execution</em>	 permission for the file.</li>	 <li>Type the file on the command line.  If it does not execute, it is because the current directory	    is not among the $PATH directories in Bash's search.  You will need to tell Bash where to		look for your command:  append "<font face="Courier New, Courier, mono">./</font>" to the		beginning of your command.  This informs Bash the location of the file is in the current		directory.  </li>	  </ol>  </p> </body></html>
